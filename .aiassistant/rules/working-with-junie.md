---
apply: manually
---

Working with Junie

## 1. Junie's Role & Seniority
Junie is treated as a **Staff-Level Software Engineer Agent**.
- **What this means:** You don't just give it "line-by-line" instructions. Instead, you provide intent, architectural constraints, and high-level requirements.
- **Trust but Verify:** While Junie has deep project context and follows rules perfectly, the human developer remains the "Architect" and "Final Approver".

## 2. When to Use Junie
### ✅ Optimal Tasks
- **Feature Implementation:** Implementing full vertical slices (Controller -> Service -> Repository).
- **Refactoring:** Modernizing code (e.g., converting classes to Records, implementing Virtual Threads).
- **Test Generation:** Writing unit, integration, and performance tests for existing or new code.
- **Bug Fixing:** Providing a stack trace or a failing test and letting Junie "Self-Heal" the codebase.
- **Documentation:** Keeping `architecture.md`, API docs, and KDoc up to date with new functionalities.

### ❌ Sub-optimal Tasks
- **Vague Architecture Decisions:** Don't ask Junie "What should I build?". Instead, ask "Given our `architecture.md`, how should we implement X?".
- **Highly Sensitive Security Logic:** Always perform extra manual audits on authentication/encryption logic generated by AI.

## 3. Efficient & Cost-Effective Usage
To minimize token usage and maximize quality:
- **Enforce Architectural Alignment:** Ensure Junie scans `.aiassistant/rules/architecture.md` by explicitly mentioning it in your initial prompt (e.g., "Implement X following our `architecture.md`"). Since it has `apply: always`, Junie uses it as a system prompt, but explicit mention ensures high-priority alignment.
- **Cost Awareness & Tracking:**
    - Use the `/stats` or `/tokens` command to check usage for the current session.
    - Monitor the "Token Meter" in the Junie UI.
    - Avoid "Looping": If Junie fails a task 3 times, stop and provide manual guidance rather than letting it retry blindly.
- **Use Context Wisely:** Use `@projectStructure` or reference specific files only when needed. Don't force Junie to read the whole repo for a single file fix.
- **Rule-Driven Development:** Keep `.aiassistant/rules/` updated. Junie consumes these rules as "System Instructions," reducing the need for you to repeat style preferences in every prompt.
- **Incremental Changes:** Prefer small, verifiable steps over massive "do everything at once" prompts. This reduces the blast radius of potential errors and makes reviews easier.

## 4. Daily Task Step-by-Step Guide
Follow this routine for standard daily development:

1.  **Stand-up & Context:** Identify your task (e.g., a ticket). Open the relevant files in your IDE.
2.  **Architectural Alignment:** Start the chat by referencing the blueprint: *"@projectStructure Scan `.aiassistant/rules/architecture.md`. I am a [your role] about to implement [Task Name]. Does this conflict with our current architecture?"*
3.  **The "Plan First" Loop:**
    - Ask for a plan: *"Provide a step-by-step plan for [Task Name]. Don't write code yet."*
    - Review the plan for domain alignment, record usage, and virtual threads.
    - Adjust: *"The plan looks good, but move the validation logic to the Service layer."*
4.  **Implementation (Code Mode):** Once the plan is approved, say *"Proceed with implementation."*
5.  **Cost Check:** Run `/tokens` to ensure the implementation didn't blow the budget.
6.  **Final Review:** Use the IDE diff tool to review Junie's changes before committing.